<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>æœ€å¼·ãƒ‰ã‚¯ã‚¿ãƒ¼ã€œæ—©ãæ‚£è€…ã‚’å¸°ãã†ï¼ã€œ</title>
  <style>
    :root{ --gap:12px; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
      background:#ffffff;
      color:#0f172a;
    }
    .wrap{ max-width: 1100px; margin: 0 auto; padding: 18px 14px 44px; }
    .card{
      background:#ffffff;
      border:1px solid #e5e7eb;
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 10px 26px rgba(15, 23, 42, 0.06);
    }
    h1{ margin:0 0 10px; font-size:18px; font-weight: 900; }
    .stack{ display:flex; flex-direction: column; gap: var(--gap); }

    .hud{
      border:1px solid #e5e7eb;
      border-radius: 18px;
      padding: 14px;
      background:#ffffff;
      box-shadow: 0 10px 26px rgba(15, 23, 42, 0.05);
    }
    .row3{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:var(--gap); }
    .stat{
      padding: 12px;
      border:1px solid #e5e7eb;
      border-radius: 16px;
      background:#f8fafc;
      min-width:0;
    }
    .label{ font-size:10px; color:#64748b; }
    .value{ margin-top:4px; font-size:16px; font-weight:800; }

    .comboWrap{ margin-top:8px; }
    .comboLine{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .comboText{ font-size:10px; color:#334155; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .barOuter{
      margin-top:6px;
      height: 10px;
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      background:#ffffff;
      overflow:hidden;
    }
    .barInner{
      height:100%;
      width:0%;
      background:#1d4ed8;
      transition: width 120ms linear;
    }

    .msg{ min-height: 22px; font-size: 14px; color:#334155; margin-top:10px; }
    .msg.ok{ color:#059669; }
    .msg.ng{ color:#dc2626; }

    .field{
      position: relative;
      width: 100%;
      height: 220px;
      border-radius: 18px;
      border: 1px solid #e5e7eb;
      background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);
      overflow: hidden;
      box-shadow: inset 0 1px 0 rgba(15,23,42,0.04);
      outline:none;
    }
    .leftLine{
      position:absolute;
      left: 86px; top:0; bottom:0;
      width: 3px;
      background: rgba(220,38,38,0.70);
      box-shadow: 0 0 16px rgba(220,38,38,0.12);
    }
    .leftHint{
      position:absolute; left: 14px; top: 10px;
      font-size: 12px;
      color:#64748b;
    }

    .patient{
      position:absolute;
      width: 560px;
      max-width: calc(100% - 24px);
      border-radius: 18px;
      border: 1px solid #e5e7eb;
      background:#ffffff;
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.10);
      padding: 14px 14px;
      will-change: top,left;
    }
    .pTop{ display:flex; justify-content: space-between; align-items: baseline; gap: 12px; }
    .pLeft{ display:flex; align-items: baseline; gap: 10px; }
    .emoji{ font-size: 22px; line-height: 1; }

    /* æ—¥æœ¬èªã¯å¤§ãã */
    .term{ font-weight: 950; font-size: 22px; letter-spacing: 0.02em; }

    .badge{
      font-size: 12px;
      color:#0f172a;
      background:#f1f5f9;
      border:1px solid #e5e7eb;
      padding: 3px 10px;
      border-radius: 999px;
      white-space: nowrap;
    }

    .termBlock{
      display:flex;
      flex-direction:column;
      gap:6px;
    }

    /* ãƒ­ãƒ¼ãƒå­—ã¯å°ã•ã */
    .romaji{
      margin-top: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 16px;
      letter-spacing: 0.10em;
      text-transform: lowercase;
      user-select: none;
      white-space: nowrap;
      overflow-x: auto;
      padding-bottom: 2px;
    }
    .romaji .done{ color: rgba(15,23,42,0.10); }
    .romaji .todo{ color: rgba(15,23,42,0.92); }
    .romaji .cursor{ border-bottom: 2px solid rgba(15,23,42,0.90); padding-bottom: 1px; }

    .typedGhost{
      margin-top: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      color:#94a3b8;
      letter-spacing: 0.08em;
      user-select:none;
    }

    .patientExit{
      opacity: 0;
      transition: opacity 240ms ease-out;
    }


    .startOverlay{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      flex-direction:column;
      gap:10px;
      background: rgba(248,250,252,0.96);
      backdrop-filter: blur(6px);
      z-index: 9998;
      text-align:center;
      padding: 20px;
    }
    .startOverlayPanel{
      width: min(420px, 92vw);
      background:#ffffff;
      border:1px solid #e5e7eb;
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.12);
      padding: 18px 16px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
    }
    .startOverlayBtn{
      width: 260px;
      padding: 14px 16px;
      border-radius: 16px;
      border: 1px solid #dbeafe;
      background: #eff6ff;
      color:#1d4ed8;
      font-weight: 900;
      cursor: pointer;
    }
    .startOverlayBtn:hover{ background:#dbeafe; }
    .startOverlaySub{ font-size: 12px; color:#64748b; }
    .finalScore{ font-size: 14px; color:#0f172a; font-weight: 900; }
    .menuTitle{ font-weight: 900; font-size: 16px; }
    .menuOptions{ display:flex; flex-direction:column; gap:8px; width: 260px; }
    .menuBtn{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid #e2e8f0;
      background:#ffffff;
      cursor:pointer;
      font-weight: 700;
    }
    .menuBtn span{ font-size:12px; color:#64748b; font-weight:700; }
    .menuBtn.active{
      border-color:#1d4ed8;
      background:#eff6ff;
      color:#1d4ed8;
    }
    .menuNote{ font-size: 12px; color:#475569; }

    .hudActions{
      display:flex;
      justify-content:flex-end;
      gap:8px;
      margin-top: 4px;
    }
    .hudActions button{
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid #e2e8f0;
      background: #f8fafc;
      cursor: pointer;
      font-weight: 700;
      font-size: 11px;
    }
    .hudActions button:hover{ background:#e2e8f0; }
    .modeInfo{ margin-top:6px; font-size: 12px; color:#64748b; }

    /* âœ… é€æ˜å…¥åŠ›ã‚­ãƒ£ãƒ—ãƒãƒ£ï¼ˆã“ã‚Œã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã—ã¦ã‚­ãƒ¼ã‚’æ‹¾ã†ï¼‰ */
    #captureInput{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      opacity:0;
      border:none;
      outline:none;
      background:transparent;
      z-index: 5;
      ime-mode: disabled;
    }

    @media (max-width: 820px){
      .row3{ grid-template-columns:1fr; }
      .patient{ width: 520px; }
    }
    /* âœ… çµæœãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— */
.resultModal{
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(15,23,42,0.55);
  z-index: 9999;
  padding: 16px;
}
.resultModal.show{ display:flex; }

.resultCard{
  width: min(520px, 100%);
  background: #ffffff;
  border: 1px solid #e5e7eb;
  border-radius: 18px;
  padding: 16px;
  box-shadow: 0 18px 40px rgba(15, 23, 42, 0.20);
}
.resultTitle{
  font-weight: 950;
  font-size: 18px;
  margin-bottom: 10px;
}
.resultBody{
  font-size: 14px;
  color: #0f172a;
  line-height: 1.65;
}
.resultBody .big{
  font-size: 28px;
  font-weight: 950;
  margin: 6px 0 8px;
}
.resultBody .muted{ color:#64748b; font-size:12px; }
.resultBtns{
  display:flex;
  gap: 10px;
  margin-top: 14px;
}
.resultBtns button{
  width: 100%;
}

.infoToast{
  position: fixed;
  left: 50%;
  top: 18px;
  transform: translateX(-50%);
  background: #0f172a;
  color: #ffffff;
  padding: 10px 14px;
  border-radius: 999px;
  font-size: 12px;
  display: none;
  z-index: 10000;
  box-shadow: 0 10px 26px rgba(15, 23, 42, 0.30);
}
.infoToast.show{ display:block; }

  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>æœ€å¼·ãƒ‰ã‚¯ã‚¿ãƒ¼ã€œæ—©ãæ‚£è€…ã‚’å¸°ãã†ï¼ã€œ</h1>

    <div class="stack">
      <div class="hud">
        <div class="row3">
          <div class="stat"><div class="label">æ®‹ã‚Šæ™‚é–“</div><div class="value" id="timeLeft">60.0</div></div>
          <div class="stat"><div class="label">ã‚¹ã‚³ã‚¢</div><div class="value" id="score">0</div></div>

          <div class="stat">
            <div class="label">ã‚³ãƒ³ãƒœï¼ˆé€£ç¶šã‚¿ã‚¤ãƒ”ãƒ³ã‚°æ•°ï¼‰</div>
            <div class="value" id="comboNum">0</div>
            <div class="comboWrap">
              <div class="comboLine">
                <div class="comboText" id="comboText">æ¬¡(+1s)ã¾ã§ 20 æ–‡å­—</div>
                <div class="comboText" id="comboBonus">ç¾åœ¨ï¼š+0s</div>
              </div>
              <div class="barOuter"><div class="barInner" id="comboBar"></div></div>
            </div>
          </div>
        </div>

          <div class="hudActions">
            <button id="pauseBtn" type="button">ä¸€æ™‚åœæ­¢</button>
            <button id="restartBtn" type="button">ã‚„ã‚Šç›´ã—</button>
            <button id="quitBtn" type="button">ã‚„ã‚ã‚‹</button>
            <button id="volumeBtn" type="button">éŸ³é‡ï¼š50%</button>
          </div>
          <div class="msg" id="msg"></div>
          <div class="modeInfo" id="modeInfo"></div>
      </div>

      <div class="field" id="field" tabindex="0" aria-label="game field">
        <div class="leftLine"></div>
        <div class="leftHint">èµ¤ç·šã‚’è¶Šãˆã‚‹å‰ã«å®Œäº†</div>

        <div class="startOverlay" id="startOverlay">
          <div class="startOverlayPanel">
            <div class="menuTitle">é›£ã—ã•ã‚’é¸ã‚“ã§ãã ã•ã„</div>
            <div class="menuOptions" id="modeMenu">
              <button class="menuBtn" type="button" data-mode="easy">ã‚„ã•ã—ã„ <span>1000pt</span></button>
              <button class="menuBtn" type="button" data-mode="normal">ãµã¤ã† <span>3000pt</span></button>
              <button class="menuBtn" type="button" data-mode="hard">ã‚€ãšã‹ã—ã„ <span>5000pt</span></button>
            </div>
            <div class="menuNote">ã§ãã‚‹ã ã‘å¤šãã®æ‚£è€…ã‚’è¿”ã—ã¾ã—ã‚‡ã†ï¼</div>
            <button class="startOverlayBtn" id="playBtn" type="button">é–‹å§‹</button>
            <div class="finalScore" id="finalScore"></div>
            <div class="startOverlaySub" id="overlaySub">ã‚¯ãƒªãƒƒã‚¯ã§é–‹å§‹ï¼ˆå…¥åŠ›ã‚’æœ‰åŠ¹åŒ–ï¼‰</div>
          </div>
        </div>

        <input id="captureInput" autocomplete="off" autocapitalize="none" spellcheck="false" inputmode="none" lang="en" />
      </div>
    </div>
  </div>
</div>
<div id="infoToast" class="infoToast">ã§ãã‚‹ã ã‘å¤šãã®æ‚£è€…ã‚’è¿”ã—ã¾ã—ã‚‡ã†ï¼</div>
<!-- âœ… çµæœãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— -->
<div id="resultModal" class="resultModal" aria-hidden="true">
  <div class="resultCard">
    <div class="resultTitle">çµæœ</div>
    <div id="resultBody" class="resultBody"></div>
    <div class="resultBtns">
      <button id="retryBtn" type="button">ã‚‚ã†ä¸€å›</button>
      <button id="closeBtn" type="button">é–‰ã˜ã‚‹</button>
    </div>
  </div>
</div>

<script>
(() => {
  const field = document.getElementById("field");
  const captureInput = document.getElementById("captureInput");
  const startOverlay = document.getElementById("startOverlay");
  const playBtn = document.getElementById("playBtn");
  const finalScore = document.getElementById("finalScore");
  const overlaySub = document.getElementById("overlaySub");

  const elTime = document.getElementById("timeLeft");
  const elScore = document.getElementById("score");
  const elMsg   = document.getElementById("msg");
  const elComboNum = document.getElementById("comboNum");
  const elComboText = document.getElementById("comboText");
  const elComboBonus = document.getElementById("comboBonus");
  const elComboBar = document.getElementById("comboBar");
  const modeInfo = document.getElementById("modeInfo");
  const pauseBtn = document.getElementById("pauseBtn");
  const restartBtn = document.getElementById("restartBtn");
  const quitBtn = document.getElementById("quitBtn");
  const volumeBtn = document.getElementById("volumeBtn");
  const infoToast = document.getElementById("infoToast");
  const modeMenu = document.getElementById("modeMenu");
  const modeButtons = Array.from(document.querySelectorAll(".menuBtn"));

  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const now=()=>performance.now();
  const resultModal = document.getElementById("resultModal");
  const resultBody  = document.getElementById("resultBody");
  const retryBtn    = document.getElementById("retryBtn");
  const closeBtn    = document.getElementById("closeBtn");

// âœ… é›†è¨ˆ
let totalTyped = 0;    // æ‰“éµæ•°ï¼ˆè‹±æ•°å­—ï¼‰
let totalCorrect = 0;  // æ­£ã—ãé€šã£ãŸæ‰“éµæ•°
let totalMiss = 0;     // ãƒŸã‚¹æ‰“éµæ•°
let gameStartAt = 0;   // é–‹å§‹æ™‚åˆ»
let extraNTolerance = 0;

  const audioAssets = {
    click: new Audio("assets/audio/sfx/click.mp3"),
    typing: new Audio("assets/audio/sfx/typing.mp3"),
    correct: new Audio("assets/audio/sfx/correct.mp3"),
    miss: new Audio("assets/audio/sfx/miss.mp3"),
    end: new Audio("assets/audio/sfx/game_end.mp3"),
    bgm: new Audio("assets/audio/bgm/game_main.mp3"),
  };
  audioAssets.bgm.loop = true;
  const volumeLevels = [0, 0.5, 1];
  let volumeIndex = 1;
  function applyVolume(){
    const volume = volumeLevels[volumeIndex];
    Object.values(audioAssets).forEach((audio) => {
      audio.volume = volume;
    });
    volumeBtn.textContent = `éŸ³é‡ï¼š${Math.round(volume * 100)}%`;
  }
  function playAudio(audio){
    if(!audio) return;
    audio.currentTime = 0;
    audio.play().catch(() => {});
  }
  applyVolume();

  function calcLevel(effectiveCpm){
    const level = Math.round((effectiveCpm / 400) * 100);
    return clamp(level, 1, 100);
  }
  function gradeFromLevel(level){
    if(level >= 81) return "ãƒ¬ã‚¸ã‚§ãƒ³ãƒ‰";
    if(level >= 61) return "ãƒ™ãƒ†ãƒ©ãƒ³";
    if(level >= 41) return "ä¸­å …";
    if(level >= 21) return "æ–°äºº";
    return "å­¦ç”Ÿ";
  }
  function showResultPopup({score, elapsedSec, correct, typed, miss, modeLabel, modeBase}){
    const min = Math.max(0.0001, elapsedSec / 60);
    const cpm = correct / min;
    const acc = typed ? (correct / typed) : 0;
    const effectiveCpm = cpm * acc; // æ­£ç¢ºã•è¾¼ã¿ã®å®ŸåŠ¹é€Ÿåº¦
    const level = calcLevel(effectiveCpm);
    const grade = gradeFromLevel(level);

    const accPct = Math.round(acc * 1000) / 10; // 0.1%åˆ»ã¿
    resultBody.innerHTML = `
      <div class="big">ãƒ¬ãƒ™ãƒ« ${level}ï¼ˆ${grade}ï¼‰</div>
      <div>ã‚¹ã‚³ã‚¢ï¼š<b>${score}</b>pt</div>
      <div>ã‚¿ã‚¤ãƒ”ãƒ³ã‚°åŠ ç®—ï¼š<b>+${score}</b>pt</div>
      <div>ãƒ¢ãƒ¼ãƒ‰ï¼š${modeLabel}ï¼ˆåŸºæº– ${modeBase}pt / 20å•ç›®å®‰ï¼‰</div>
      <div>å®ŸåŠ¹CPMï¼ˆæ­£ç¢ºã•è¾¼ã¿ï¼‰ï¼š<b>${Math.round(effectiveCpm)}</b></div>
      <div>CPMï¼š${Math.round(cpm)} / æ­£ç¢ºç‡ï¼š${accPct}%</div>
      <div>æ­£æ‰“éµï¼š${correct} / æ‰“éµï¼š${typed} / ãƒŸã‚¹ï¼š${miss}</div>
      <div>çµŒéï¼š${elapsedSec.toFixed(1)} ç§’</div>
    `;
    resultModal.classList.add("show");
    resultModal.setAttribute("aria-hidden", "false");
  }
  function hideResultPopup(){
    resultModal.classList.remove("show");
    resultModal.setAttribute("aria-hidden", "true");
  }
  closeBtn.addEventListener("click", () => {
    playAudio(audioAssets.click);
    hideResultPopup();
  });
  resultModal.addEventListener("pointerdown", (e) => {
    if(e.target === resultModal) hideResultPopup();
  });
  retryBtn.addEventListener("click", () => {
    playAudio(audioAssets.click);
    hideResultPopup();
    startOrRestart();
  });


  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }
  function setMsg(text, kind){
    elMsg.textContent = text || "";
    elMsg.className = "msg " + (kind || "");
  }
  const DATA_URL_KEY = "medicaltypingDataUrl";
  function setDataStatus(text, kind){
    dataStatus.textContent = text || "";
    if(kind === "ok"){
      dataStatus.style.color = "#059669";
    }else if(kind === "ng"){
      dataStatus.style.color = "#dc2626";
    }else{
      dataStatus.style.color = "#0f172a";
    }
  }
  function escapeHtml(s){
    return (s||"").replace(/[&<>"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }
  function normBase(s){ return (s||"").toLowerCase().replace(/\s+/g,"").replace(/[^a-z0-9]/g,""); }

  // ===== Kana -> Romajiï¼ˆæ··åœ¨OK / ã—ã‚…=syu, ã¡ã‚…=tyu / ãµ=huåŸºæº–ï¼‰=====
const KANA_MAP = (() => {
  const m = {};
  const add = (k,v)=>m[k]=v;

  // ---- æ‹—éŸ³ï¼ˆ2æ–‡å­—ï¼‰----
  [
    // k
    ["ãã‚ƒ","kya"],["ãã‚…","kyu"],["ãã‚‡","kyo"],
    ["ãã‚ƒ","gya"],["ãã‚…","gyu"],["ãã‚‡","gyo"],

    // sï¼ˆè¦‹æœ¬ï¼šsya/syu/syoï¼‰
    ["ã—ã‚ƒ","sya"],["ã—ã‚…","syu"],["ã—ã‚‡","syo"],
    ["ã˜ã‚ƒ","zya"],["ã˜ã‚…","zyu"],["ã˜ã‚‡","zyo"], // ã˜ã‚ƒè¡Œã¯ zya/zyu/zyo
    ["ã¡ã‚ƒ","tya"],["ã¡ã‚…","tyu"],["ã¡ã‚‡","tyo"], // ã¡ã‚ƒè¡Œã¯ tya/tyu/tyo

    // n
    ["ã«ã‚ƒ","nya"],["ã«ã‚…","nyu"],["ã«ã‚‡","nyo"],

    // hï¼ˆãµãç³»ã¯faï¼‰
    ["ã²ã‚ƒ","hya"],["ã²ã‚…","hyu"],["ã²ã‚‡","hyo"],
    ["ã³ã‚ƒ","bya"],["ã³ã‚…","byu"],["ã³ã‚‡","byo"],
    ["ã´ã‚ƒ","pya"],["ã´ã‚…","pyu"],["ã´ã‚‡","pyo"],
    ["ã¿ã‚ƒ","mya"],["ã¿ã‚…","myu"],["ã¿ã‚‡","myo"],
    ["ã‚Šã‚ƒ","rya"],["ã‚Šã‚…","ryu"],["ã‚Šã‚‡","ryo"],

    // fï¼ˆãµã/ãµãƒ/ãµã‡/ãµã‰ï¼‰
    ["ãµã","fa"],["ãµãƒ","fi"],["ãµã‡","fe"],["ãµã‰","fo"],
  ].forEach(([k,v])=>add(k,v));

  // ---- åŸºæœ¬1æ–‡å­— ----
  [
    ["ã‚","a"],["ã„","i"],["ã†","u"],["ãˆ","e"],["ãŠ","o"],
    ["ã‹","ka"],["ã","ki"],["ã","ku"],["ã‘","ke"],["ã“","ko"],
    ["ã•","sa"],["ã—","si"],["ã™","su"],["ã›","se"],["ã","so"],
    ["ãŸ","ta"],["ã¡","ti"],["ã¤","tu"],["ã¦","te"],["ã¨","to"],
    ["ãª","na"],["ã«","ni"],["ã¬","nu"],["ã­","ne"],["ã®","no"],
    ["ã¯","ha"],["ã²","hi"],["ãµ","hu"],["ã¸","he"],["ã»","ho"],
    ["ã¾","ma"],["ã¿","mi"],["ã‚€","mu"],["ã‚","me"],["ã‚‚","mo"],
    ["ã‚„","ya"],["ã‚†","yu"],["ã‚ˆ","yo"],
    ["ã‚‰","ra"],["ã‚Š","ri"],["ã‚‹","ru"],["ã‚Œ","re"],["ã‚","ro"],
    ["ã‚","wa"],["ã‚’","wo"],["ã‚“","n"],

    // æ¿ç‚¹
    ["ãŒ","ga"],["ã","gi"],["ã","gu"],["ã’","ge"],["ã”","go"],
    ["ã–","za"],["ã˜","zi"],["ãš","zu"],["ãœ","ze"],["ã","zo"],
    ["ã ","da"],["ã¢","di"],["ã¥","du"],["ã§","de"],["ã©","do"],
    ["ã°","ba"],["ã³","bi"],["ã¶","bu"],["ã¹","be"],["ã¼","bo"],

    // åŠæ¿ç‚¹
    ["ã±","pa"],["ã´","pi"],["ã·","pu"],["ãº","pe"],["ã½","po"],

    // å°æ›¸ã
    ["ã","a"],["ãƒ","i"],["ã…","u"],["ã‡","e"],["ã‰","o"],
    ["ã‚ƒ","ya"],["ã‚…","yu"],["ã‚‡","yo"],

    // é•·éŸ³ï¼ˆã‹ãªå´ã§æ®‹ã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã§ä¸€å¿œï¼‰
    ["ãƒ¼","-"],
  ].forEach(([k,v])=>add(k,v));

  const kataToHira = (s)=>s.replace(/[\u30A1-\u30F6]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0x60));
  m.__kataToHira = kataToHira;
  return m;
})();

  function kanaToRomaji(input){
    if(!input) return "";
    let s = KANA_MAP.__kataToHira(input).replace(/\s+/g,"");

    let out = "";
    for(let i=0;i<s.length;i++){
      const ch = s[i];

      if(/[a-z0-9]/i.test(ch)){
        out += ch.toLowerCase();
        continue;
      }

      // ã‚“ï¼šæ¬¡ãŒæ¯éŸ³/y/n ãªã‚‰ nnï¼ˆã€œã‚“ãªã—å¯¾ç­–ï¼‰
      if(ch === "ã‚“"){
  out += "n";       // âœ… å¸¸ã« nï¼ˆãƒ™ãƒ¼ã‚¹ã‚’å˜ç´”åŒ–ï¼‰
  continue;
}


      if(ch === "ã£"){
        const next2 = s.slice(i+1, i+3);
        const next1 = s.slice(i+1, i+2);
        const roma = (KANA_MAP[next2] || KANA_MAP[next1] || "");
        if(roma) out += roma[0];
        continue;
      }

      const two = s.slice(i, i+2);
      if(KANA_MAP[two]){
        out += KANA_MAP[two];
        i++;
        continue;
      }
      if(KANA_MAP[ch]){
        out += KANA_MAP[ch];
        continue;
      }
    }

    out = out.replace(/-/g,"");
    // nãŒå¢—ãˆã™ãã‚‹ã®ã¯æœ€å¤§ nnn ã«ä¸¸ã‚ã‚‹
    out = out.replace(/nnnn+/g,"nnn");
    return normBase(out);
  }

  // ===== BANKï¼šå®Œæˆãƒ•ãƒ¬ãƒ¼ã‚ºã®ã¿ï¼ˆçµ„ã¿åˆã‚ã›ç”Ÿæˆãªã—ï¼‰=====
  // å½¢å¼ï¼šterm|yomi|emoji|badge|level
  // yomi ã¯ã€Œã²ã‚‰ãŒãªï¼‹è‹±æ•°å­—ã€ã ã‘ã«ã—ã¦ãŠãã¨å®‰å®šï¼ˆct, crp, spo2ç­‰OKï¼‰
const PHRASE_LINES = `
é ­ç—›|ãšã¤ã†|ğŸ§ |ç—‡çŠ¶
è…¹ç—›|ãµãã¤ã†|ğŸ¤¢|ç—‡çŠ¶
ç™ºç†±|ã¯ã¤ã­ã¤|ğŸ”¥|ç—‡çŠ¶
å’³|ã›ã|ğŸ˜·|ç—‡çŠ¶
ç—°|ãŸã‚“|ğŸ«§|ç—‡çŠ¶
åæ°—|ã¯ã|ğŸ¤®|ç—‡çŠ¶
ä¸‹ç—¢|ã’ã‚Š|ğŸš½|ç—‡çŠ¶
ä¾¿ç§˜|ã¹ã‚“ã´|ğŸª |ç—‡çŠ¶
ä¸çœ |ãµã¿ã‚“|ğŸŒ™|ç—‡çŠ¶
ä¸å®‰|ãµã‚ã‚“|ğŸ˜µâ€ğŸ’«|ç—‡çŠ¶
ã‚ã¾ã„|ã‚ã¾ã„|ğŸŒ€|ç—‡çŠ¶
å¤±ç¥|ã—ã£ã—ã‚“|ğŸ˜µâ€ğŸ’«|ç—‡çŠ¶
å‹•æ‚¸|ã©ã†ã|ğŸ’“|ç—‡çŠ¶
æ¯åˆ‡ã‚Œ|ã„ããã‚Œ|ğŸ«|ç—‡çŠ¶
èƒ¸ç—›|ãã‚‡ã†ã¤ã†|ğŸ’¥|ç—‡çŠ¶
èƒŒç—›|ã¯ã„ã¤ã†|ğŸ«€|ç—‡çŠ¶
å€¦æ€ |ã‘ã‚“ãŸã„|ğŸ˜®â€ğŸ’¨|ç—‡çŠ¶
çš®ç–¹|ã²ã—ã‚“|ğŸ©¹|ç—‡çŠ¶
æµ®è…«|ãµã—ã‚…|ğŸ¦µ|ç—‡çŠ¶
è²§è¡€|ã²ã‚“ã‘ã¤|ğŸ©¸|ç—‡çŠ¶
è¡€å°¿|ã‘ã¤ã«ã‚‡ã†|ğŸ©¸|ç—‡çŠ¶
åè¡€|ã¨ã‘ã¤|ğŸ©¸|ç—‡çŠ¶

è¡€åœ§|ã‘ã¤ã‚ã¤|ğŸ©º|ãƒã‚¤ã‚¿ãƒ«
è„ˆæ‹|ã¿ã‚ƒãã¯ã|ğŸ«€|ãƒã‚¤ã‚¿ãƒ«
å‘¼å¸|ã“ãã‚…ã†|ğŸ«|ãƒã‚¤ã‚¿ãƒ«
ä½“æ¸©|ãŸã„ãŠã‚“|ğŸŒ¡ï¸|ãƒã‚¤ã‚¿ãƒ«
æ„è­˜|ã„ã—ã|ğŸ§ |ãƒã‚¤ã‚¿ãƒ«

æ¡è¡€|ã•ã„ã‘ã¤|ğŸ§ª|æ¤œæŸ»
å°¿æ¤œ|ã«ã‚‡ã†ã‘ã‚“|ğŸ§ª|æ¤œæŸ»
å¿ƒé›»|ã—ã‚“ã§ã‚“|ğŸ§ª|æ¤œæŸ»
CT|ct|ğŸ§ª|æ¤œæŸ»
è¡€ç³–|ã‘ã£ã¨ã†|ğŸ§ª|æ¤œæŸ»

æŠ•è–¬|ã¨ã†ã‚„ã|ğŸ’Š|å‡¦æ–¹
å†…æœ|ãªã„ãµã|ğŸ’Š|å‡¦æ–¹
ç‚¹æ»´|ã¦ã‚“ã¦ã|ğŸ’§|å‡¦æ–¹

å®‰é™|ã‚ã‚“ã›ã„|ğŸ›Œ|æŒ‡ç¤º
æ°´åˆ†|ã™ã„ã¶ã‚“|ğŸ¥¤|æŒ‡ç¤º
é‹å‹•|ã†ã‚“ã©ã†|ğŸƒ|æŒ‡ç¤º
ç¡çœ |ã™ã„ã¿ã‚“|ğŸŒ™|æŒ‡ç¤º
ç¦ç…™|ãã‚“ãˆã‚“|ğŸš­|æŒ‡ç¤º
å†è¨º|ã•ã„ã—ã‚“|ğŸ“…|æŒ‡ç¤º
  `.trim();

  const LEVEL_ALIASES = new Map([
    ["easy", "easy"],
    ["e", "easy"],
    ["ç°¡å˜", "easy"],
    ["ã‚„ã•ã—ã„", "easy"],
    ["æ˜“", "easy"],
    ["normal", "normal"],
    ["n", "normal"],
    ["æ™®é€š", "normal"],
    ["ãµã¤ã†", "normal"],
    ["æ¨™æº–", "normal"],
    ["hard", "hard"],
    ["h", "hard"],
    ["é›£ã—ã„", "hard"],
    ["ã‚€ãšã‹ã—ã„", "hard"],
    ["é›£", "hard"],
  ]);
  function normalizeLevel(value){
    const raw = String(value ?? "").trim();
    if(!raw) return "normal";
    const lower = raw.toLowerCase();
    return LEVEL_ALIASES.get(lower) || LEVEL_ALIASES.get(raw) || "normal";
  }

  function normalizeEntry(entry){
    if(!entry) return null;
    const term = String(entry.term || entry.å˜èª || entry.word || "").trim();
    const yomi = String(entry.yomi || entry.reading || entry.ã‚ˆã¿ || "").trim();
    if(!term || !yomi) return null;
    if(/[ã‚“ãƒ³]$/.test(term)) return null; // èªå°¾ã€Œã‚“ã€é™¤å¤–ï¼ˆå¿µã®ãŸã‚ï¼‰
    const emojiRaw = entry.emoji ?? entry.icon ?? "ğŸ§‘â€âš•ï¸";
    const badgeRaw = entry.badge ?? entry.category ?? entry.åˆ†é¡ ?? "å¤–æ¥";
    const levelRaw = entry.level ?? entry.difficulty ?? entry.é›£æ˜“åº¦ ?? entry.level;
    return {
      term,
      baseRomaji: kanaToRomaji(yomi),
      emoji: String(emojiRaw).trim() || "ğŸ§‘â€âš•ï¸",
      badge: String(badgeRaw).trim() || "å¤–æ¥",
      level: normalizeLevel(levelRaw),
    };
  }

  function buildBankFromEntries(entries){
    const bank = [];
    for(const entry of entries){
      const normalized = normalizeEntry(entry);
      if(!normalized) continue;
      bank.push(normalized);
    }
    return bank;
  }

  function buildBankFromLines(text){
    const lines = text.split("\n").map(s => s.trim()).filter(Boolean);
    const entries = [];
    for(const line of lines){
      const [term,yomi,emoji,badge,level] = line.split("|").map(s=> (s??"").trim());
      if(!term || !yomi) continue;
      entries.push({ term, yomi, emoji, badge, level });
    }
    return buildBankFromEntries(entries);
  }

  function parseCsvRow(row){
    const cells = [];
    let cur = "";
    let inQuotes = false;
    for(let i=0; i<row.length; i++){
      const ch = row[i];
      if(ch === "\""){
        if(inQuotes && row[i+1] === "\""){
          cur += "\"";
          i += 1;
        }else{
          inQuotes = !inQuotes;
        }
      }else if(ch === "," && !inQuotes){
        cells.push(cur);
        cur = "";
      }else{
        cur += ch;
      }
    }
    cells.push(cur);
    return cells.map(c => c.trim());
  }

  function buildBankFromCsv(text){
    const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    if(!lines.length) return [];
    const rows = lines.map(parseCsvRow);
    const header = rows[0].map(h => h.trim());
    const lowerHeader = header.map(h => h.toLowerCase());
    const hasHeader = header.some((h, idx) => ["term","yomi","reading","emoji","badge","level","å˜èª","ã‚ˆã¿","é›£æ˜“åº¦"].includes(h) || ["term","yomi","reading","emoji","badge","level"].includes(lowerHeader[idx]));
    const dataRows = hasHeader ? rows.slice(1) : rows;
    const findIndex = (names) => {
      for(const name of names){
        const lower = name.toLowerCase();
        const idxLower = lowerHeader.indexOf(lower);
        if(idxLower !== -1) return idxLower;
        const idx = header.indexOf(name);
        if(idx !== -1) return idx;
      }
      return -1;
    };
    const indices = {
      term: hasHeader ? findIndex(["term","å˜èª","word"]) : 0,
      yomi: hasHeader ? findIndex(["yomi","reading","ã‚ˆã¿"]) : 1,
      emoji: hasHeader ? findIndex(["emoji","icon"]) : 2,
      badge: hasHeader ? findIndex(["badge","category","åˆ†é¡"]) : 3,
      level: hasHeader ? findIndex(["level","difficulty","é›£æ˜“åº¦"]) : 4,
    };
    const entries = dataRows.map(row => ({
      term: row[indices.term] || "",
      yomi: row[indices.yomi] || "",
      emoji: row[indices.emoji] || "",
      badge: row[indices.badge] || "",
      level: row[indices.level] || "",
    }));
    return buildBankFromEntries(entries);
  }

  function parseDataText(text){
    const trimmed = text.trim();
    if(!trimmed) return [];
    if(trimmed.startsWith("{") || trimmed.startsWith("[")){
      const json = JSON.parse(trimmed);
      const items = Array.isArray(json) ? json : (json.items || json.data || []);
      return buildBankFromEntries(items);
    }
    const firstLine = trimmed.split(/\r?\n/)[0] || "";
    if(firstLine.includes("|")){
      return buildBankFromLines(trimmed);
    }
    return buildBankFromCsv(trimmed);
  }

  const BUILTIN_BANK = buildBankFromLines(PHRASE_LINES);
  let BANK = [...BUILTIN_BANK];
  if(BANK.length < 10){
    console.warn("BANK too small. Add more lines to PHRASE_LINES.");
  }

  function applyBank(nextBank, sourceLabel){
    if(!nextBank || nextBank.length < 5){
      throw new Error("å•é¡Œæ•°ãŒå°‘ãªã™ãã¾ã™ï¼ˆæœ€ä½5å•ï¼‰");
    }
    BANK = nextBank;
    resetPool();
    pointsPerChar = computePointsPerChar(currentMode.basePoints);
    if(p){
      despawnPatient();
      spawnPatient();
    }
  }

  const DEFAULT_DATA_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vRSSGtJfEZXjdJm2FKR46MsxURlOlUZ4tjzZ6nGv7_dAU-K96eI4pAlKOk3k3bgt-DEjisr2kiLDjW-/pub?gid=0&single=true&output=csv";
  async function loadBankFromUrl(url){
    const res = await fetch(url, { cache: "no-store" });
    if(!res.ok){
      throw new Error(`èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆ${res.status}ï¼‰`);
    }
    const text = await res.text();
    const bank = parseDataText(text);
    applyBank(bank, "ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆ");
  }

  const MODES = {
    easy: { label: "ã‚„ã•ã—ã„", basePoints: 1000 },
    normal: { label: "ãµã¤ã†", basePoints: 3000 },
    hard: { label: "ã‚€ãšã‹ã—ã„", basePoints: 5000 },
  };
  let currentModeKey = "easy";
  let currentMode = MODES.easy;
  let pointsPerChar = 1;

  function computePointsPerChar(basePoints){
    const avgLen = BANK.reduce((sum, item) => sum + item.baseRomaji.length, 0) / Math.max(1, BANK.length);
    const perChar = basePoints / (avgLen * 20);
    return Math.max(1, perChar);
  }

  function setMode(modeKey){
    currentMode = MODES[modeKey] || MODES.easy;
    currentModeKey = modeKey in MODES ? modeKey : "easy";
    pointsPerChar = computePointsPerChar(currentMode.basePoints);
    modeButtons.forEach(btn => {
      btn.classList.toggle("active", btn.dataset.mode === modeKey);
    });
    modeInfo.textContent = `ãƒ¢ãƒ¼ãƒ‰ï¼š${currentMode.label}ï¼ˆåŸºæº– ${currentMode.basePoints}pt / 20å•ç›®å®‰ï¼‰`;
  }

  // ===== è¡¨è¨˜ã‚†ã‚Œï¼ˆn/nn/nnn + ji/zi + ju/zyuï¼‰=====
  function makeVariants(base){
    const s0 = normBase(base);
    const rules = [
      ["shi","si"], ["si","shi"],
      ["chi","ti"], ["ti","chi"],
      ["tsu","tu"], ["tu","tsu"],

      ["hu","fu"], ["fu","hu"],

      ["ji","zi"], ["zi","ji"],
      ["ju","zyu"], ["zyu","ju"],

      ["sya","sha"], ["sha","sya"],
      ["syu","shu"], ["shu","syu"],
      ["syo","sho"], ["sho","syo"],

      ["tyu","chu"], ["chu","tyu"],

      ["fa","fua"], ["fua","fa"],
      ["fi","fui"], ["fui","fi"],
      ["fe","fue"], ["fue","fe"],
      ["fo","fuo"], ["fuo","fo"],

      ["sshi","ssi"], ["ssi","sshi"],
    ];

    const set = new Set([s0]);
    // âœ… èªæœ«ã€Œã‚“ã€ã¯ n / nn ã®ä¸¡æ–¹ã‚’æ˜ç¤ºçš„ã«è¨±å®¹
    if(s0.endsWith("n")){
      set.add(`${s0}n`);
      set.add(`${s0}nn`);
    }
    if(s0.endsWith("nn")){
      set.add(s0.slice(0, -1));
    }

    for(let pass=0; pass<3; pass++){
      const cur = Array.from(set);
      for(const str of cur){
        for(const [a,b] of rules){
          if(str.includes(a)) set.add(str.split(a).join(b));
        }
      }
    }

    // âœ… n/nn/nnn ã‚’åºƒãè¨±å®¹ï¼ˆå­éŸ³å‰ãƒ»æ¯éŸ³å‰ãƒ»nå‰ã™ã¹ã¦ï¼‰
// âœ… n/nn/nnn ã‚’ã€Œä½•æ®µéšã§ã‚‚ã€çµ„ã¿åˆã‚ã›ã§ä½œã‚‹ï¼ˆkinnennsidou å¯¾ç­–ï¼‰
{
  const consonant = "bcdfghjklmnpqrstvwxz";
  const vowelYN = "aeiouyn"; // æ¯éŸ³/y/n å‰

  const expandOnce = (src) => {
    const out = new Set([src]);

    // å­éŸ³å‰ï¼šn -> nn/nnnã€nn -> nã€nnn -> nn
    out.add(src.replace(new RegExp(`(?<!n)n(?=[${consonant}])`, "g"), "nn"));
    out.add(src.replace(new RegExp(`(?<!n)n(?=[${consonant}])`, "g"), "nnn"));
    out.add(src.replace(new RegExp(`nn(?=[${consonant}])`, "g"), "n"));
    out.add(src.replace(new RegExp(`nnn(?=[${consonant}])`, "g"), "nn"));

    // æ¯éŸ³/y/n å‰ï¼šn -> nn/nnnã€nn -> nã€nnn -> nn
    out.add(src.replace(new RegExp(`(?<!n)n(?=[${vowelYN}])`, "g"), "nn"));
    out.add(src.replace(new RegExp(`(?<!n)n(?=[${vowelYN}])`, "g"), "nnn"));
    out.add(src.replace(new RegExp(`nn(?=[${vowelYN}])`, "g"), "n"));
    out.add(src.replace(new RegExp(`nnn(?=[${vowelYN}])`, "g"), "nn"));

    // æœ«å°¾ï¼šn -> nn/nnnã€nn -> n/nnnã€nnn -> nn
    if (src.endsWith("n"))  { out.add(src + "n"); out.add(src + "nn"); }
    if (src.endsWith("nn")) { out.add(src.slice(0, -1)); out.add(src + "n"); }
    if (src.endsWith("nnn")){ out.add(src.slice(0, -1)); }

    return out;
  };

  // ğŸ” 3å›ãã‚‰ã„å›ã™ã¨ã€Œè¤‡åˆå½¢ã€ãŒååˆ†å‡ºã‚‹ï¼ˆkinnennsidou ãŒå…¥ã‚‹ï¼‰
  for (let pass = 0; pass < 3; pass++) {
    const cur = Array.from(set);
    for (const s of cur) {
      for (const t of expandOnce(s)) set.add(t);
    }
  }

  // âœ… nãŒå¢—ãˆã™ãã‚‹ã®ã¯æœ€å¤§ nnn ã«ä¸¸ã‚ã‚‹
  const cur2 = Array.from(set);
  set.clear();
  for (const s of cur2) set.add(s.replace(/nnnn+/g, "nnn"));
}

    const normalized = Array.from(set).map(s => s.replace(/nnnn+/g,"nnn"));
    const uniq = Array.from(new Set(normalized.map(normBase).filter(Boolean)));
    uniq.sort((a,b)=>a.length-b.length || a.localeCompare(b));
    return uniq;
  }

  const LEVELS = ["easy", "normal", "hard"];
  const LEVEL_ORDER = {
    easy: ["easy", "normal", "hard"],
    normal: ["normal", "easy", "hard"],
    hard: ["hard", "normal", "easy"],
  };
  const MODE_LEVEL_WEIGHTS = {
    easy: { easy: 0.6, normal: 0.4, hard: 0.0 },
    normal: { easy: 0.2, normal: 0.7, hard: 0.1 },
    hard: { easy: 0.1, normal: 0.6, hard: 0.3 },
  };

  // ===== å‡ºé¡Œé †ã¯ãƒ¬ãƒ™ãƒ«åŸºæº–ã§ãƒ©ãƒ³ãƒ€ãƒ ï¼ˆæ¯ã‚ŒãŸã‚‰è£œå……ï¼‰=====
  let pools = { easy: [], normal: [], hard: [] };
  function resetPool(){
    pools = { easy: [], normal: [], hard: [] };
    for(const level of LEVELS){
      pools[level] = shuffle(BANK.filter(item => item.level === level));
    }
  }
  let clearedCount = 0;
  function pickLevelForMode(){
    const weights = MODE_LEVEL_WEIGHTS[currentModeKey] || MODE_LEVEL_WEIGHTS.normal;
    if(currentModeKey === "hard"){
      const ramp = clamp(clearedCount / 20, 0, 1);
      const easyWeight = 0.05;
      const hardWeight = weights.hard + (0.2 * ramp);
      const normalWeight = Math.max(0, 1 - easyWeight - hardWeight);
      const roll = Math.random();
      if(roll < easyWeight) return "easy";
      if(roll < easyWeight + normalWeight) return "normal";
      return "hard";
    }
    const roll = Math.random();
    if(roll < weights.easy) return "easy";
    if(roll < weights.easy + weights.normal) return "normal";
    return "hard";
  }
  function takeFromLevel(level){
    const pool = pools[level];
    if(!pool || pool.length === 0) return null;
    return pool.pop();
  }
  function nextQuestion(){
    const allEmpty = LEVELS.every(level => pools[level].length === 0);
    if(allEmpty) resetPool();
    const target = pickLevelForMode();
    const fallback = LEVEL_ORDER[currentModeKey] || LEVEL_ORDER.normal;
    const order = [target, ...fallback.filter(level => level !== target)];
    for(const level of order){
      const item = takeFromLevel(level);
      if(item) return item;
    }
    resetPool();
    return takeFromLevel(fallback[0]) || BANK[0];
  }

  // ===== ã‚³ãƒ³ãƒœï¼ˆé€£ç¶šã‚¿ã‚¤ãƒ”ãƒ³ã‚°æ•°ï¼‰â†’åŠ ç®—ç§’ï¼ˆ+1ã€œ+5ï¼‰=====
  const CHAR_THRESH = [20, 50, 90, 140, 200];
  let comboChars = 0;
  function bonusFromChars(c){
    if(c >= 200) return 5;
    if(c >= 140) return 4;
    if(c >= 90)  return 3;
    if(c >= 50)  return 2;
    if(c >= 20)  return 1;
    return 0;
  }
  function nextCharThreshold(c){
    for(const t of CHAR_THRESH) if(c < t) return t;
    return 200;
  }
  function updateComboUI(){
    elComboNum.textContent = String(comboChars);
    const curBonus = bonusFromChars(comboChars);
    elComboBonus.textContent = `ç¾åœ¨ï¼š+${curBonus}s`;
    const next = nextCharThreshold(comboChars);
    const remain = Math.max(0, next - comboChars);
    const nextBonus = clamp(curBonus + 1, 1, 5);
    elComboText.textContent = `æ¬¡(+${nextBonus}s)ã¾ã§ ${remain} æ–‡å­—`;
    elComboBar.style.width = `${(clamp(comboChars,0,200)/200*100).toFixed(1)}%`;
  }

  // ===== ã‚¿ã‚¤ãƒãƒ¼ï¼ˆ60ç§’ï¼‹åŠ ç®—ï¼‰=====
  const START_SECONDS = 60.0;
  let timeLeft = START_SECONDS;

  // ===== ã‚²ãƒ¼ãƒ æœ¬ä½“ =====
  let running=false, lastAt=0;
  let paused=false;
  let p=null;
  let score = 0;
  let missSlowUntil = 0;

  function laneY(){
    return Math.floor(field.clientHeight * 0.35); // å°‘ã—ä¸Š
  }

  function difficultySpeed(){
    const base = 60;
    const byScore = score * 0.008;
    const byCombo = comboChars * 0.03;
    const slowFactor = now() < missSlowUntil ? 0.6 : 1;
    return clamp((base + byScore + byCombo) * slowFactor, 60, 240);
  }

  function renderRomaji(patient){
    const target = patient.activeTarget || patient.base;
    const done = target.slice(0, patient.progress);
    const todo = target.slice(patient.progress);
    const todoWithCursor = todo.length
      ? `<span class="cursor">${escapeHtml(todo[0])}</span>${escapeHtml(todo.slice(1))}`
      : "";
    patient.el.querySelector(".romaji").innerHTML = `
      <span class="done">${escapeHtml(done)}</span>
      <span class="todo">${todoWithCursor}</span>
    `;
    patient.el.querySelector(".typedGhost").textContent =
      patient.typed ? `typed: ${patient.typed}` : "typed: (none)";
  }


  function spawnPatient(){
    if(p) return;
    const q = nextQuestion();
    const base = normBase(q.baseRomaji);
    const variants = makeVariants(base);


    const el = document.createElement("div");
    el.className="patient";
    el.innerHTML=`
      <div class="pTop">
        <div class="pLeft">
          <div class="termBlock">
            <div class="term"></div>
          </div>
          <div class="emoji">${q.emoji || "ğŸ§‘â€âš•ï¸"}</div>
        </div>
        <div class="badge">${q.badge || "å¤–æ¥"}</div>
      </div>
      <div class="romaji"></div>
      <div class="typedGhost"></div>
    `;
    el.querySelector(".term").textContent = q.term;
    field.appendChild(el);

    const fieldW = field.clientWidth;
    p = {
      base, variants,
      x: fieldW + 24,
      y: laneY(),
      speed: difficultySpeed(),
      progress:0,
      activeTarget: base,
      typed:"",
      el
    };

    el.style.left = `${p.x}px`;
    el.style.top  = `${p.y}px`;
    renderRomaji(p);
    setMsg("å…¥åŠ›å—ä»˜ä¸­", "");
  }

  function despawnPatient(){ if(p){ p.el.remove(); p=null; } }

  function endGame(text){
    running = false;
    paused = false;
    // æ‚£è€…ã‚«ãƒ¼ãƒ‰æ¶ˆã™
    despawnPatient();
    playAudio(audioAssets.end);
    audioAssets.bgm.pause();

    const elapsedSec = Math.max(0, (now() - gameStartAt) / 1000);
    const min = Math.max(0.0001, elapsedSec / 60);
    const cpm = totalCorrect / min;
    const acc = totalTyped ? (totalCorrect / totalTyped) : 0;
    const effectiveCpm = cpm * acc;
    const level = calcLevel(effectiveCpm);
    const grade = gradeFromLevel(level);

    finalScore.textContent = `ã‚¹ã‚³ã‚¢ï¼š${score}pt / ãƒ¬ãƒ™ãƒ« ${level}ï¼ˆ${grade}ï¼‰`;
    overlaySub.textContent = `${text}ï¼ˆã‚‚ã†ä¸€å›ã‚„ã‚‹ï¼Ÿï¼‰`;
    playBtn.textContent = "å†é–‹";
    startOverlay.style.display = "flex";
    modeMenu.style.display = "flex";

    setMsg(`${text}ï¼šã‚¹ã‚³ã‚¢ ${score}pt`, "");
    showResultPopup({
      score,
      elapsedSec,
      correct: totalCorrect,
      typed: totalTyped,
      miss: totalMiss,
      modeLabel: currentMode.label,
      modeBase: currentMode.basePoints,
    });
  }


  function missPatient(){
    missSlowUntil = now() + 500;
    comboChars = 0;
    updateComboUI();
    timeLeft = Math.max(0, timeLeft - 5);
    setMsg("å–ã‚Šé€ƒã—ï¼ -5ç§’ï¼ˆã‚³ãƒ³ãƒœ0ï¼‰", "ng");
    playAudio(audioAssets.miss);
    despawnPatient();
    spawnPatient();
  }

  function loop(t){
    if(!running) return;
    const dt=(t-lastAt)/1000;
    lastAt=t;

    timeLeft = Math.max(0, timeLeft - dt);
    elTime.textContent = timeLeft.toFixed(1);
    if(timeLeft<=0){ endGame("æ™‚é–“åˆ‡ã‚Œ"); return; }

    if(p){
      p.speed = difficultySpeed();
      p.x -= p.speed * dt;
      p.el.style.left = `${p.x}px`;
      p.y = laneY();
      p.el.style.top = `${p.y}px`;
      if(p.x <= 86) missPatient();
    }
    requestAnimationFrame(loop);
  }

  function applyMissPenalty(penalty){
    missSlowUntil = now() + 500;
    comboChars = 0;
    updateComboUI();

    score = Math.max(0, score - penalty);
    elScore.textContent = String(score);
    playAudio(audioAssets.miss);
  }

  function resetProgress(penalty){
    if(!p) return;
    applyMissPenalty(penalty);

    p.progress=0;
    p.activeTarget=p.base;
    p.typed="";

    renderRomaji(p);
    setMsg("ãƒŸã‚¹ï¼æœ€åˆã‹ã‚‰ï¼ˆã‚³ãƒ³ãƒœ0ï¼‰", "ng");
  }

  function clearTyped(){
    if(!p) return;
    p.progress=0;
    p.activeTarget=p.base;
    p.typed="";
    renderRomaji(p);
    setMsg("å…¥åŠ›ã‚¯ãƒªã‚¢", "");
  }

 function handleTypeChar(ch){
  if(!p) return;

  if(extraNTolerance > 0){
    if(ch === "n"){
      extraNTolerance -= 1;
      return;
    }
    extraNTolerance = 0;
  }

  // ã¾ãšæ‰“éµæ•°ï¼ˆè‹±æ•°å­—ï¼‰ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
  totalTyped += 1;
  playAudio(audioAssets.typing);

  // typedæ›´æ–°
  p.typed += ch;

  // å€™è£œæ¢ç´¢
  const candidates = p.variants.filter(v => v.startsWith(p.typed));
  if(!candidates.length){
    // ãƒŸã‚¹ï¼šçµ±è¨ˆï¼†ãƒªã‚»ãƒƒãƒˆ
    totalMiss += 1;
    if(currentModeKey === "hard"){
      applyMissPenalty(10);
      p.typed = p.typed.slice(0, -1);
      p.progress = p.typed.length;
      const fallbackCandidates = p.variants.filter(v => v.startsWith(p.typed));
      fallbackCandidates.sort((a,b)=>a.length-b.length || a.localeCompare(b));
      p.activeTarget = fallbackCandidates[0] || p.base;
      renderRomaji(p);
      setMsg("ãƒŸã‚¹ï¼ãã“ã‹ã‚‰å†é–‹ï¼ˆã‚³ãƒ³ãƒœ0ï¼‰", "ng");
      return;
    }
    resetProgress(10);     // æ—¢å­˜ä»•æ§˜ï¼šãƒŸã‚¹ã§ã‚³ãƒ³ãƒœ0ãªã©
    return;
  }

  // ã“ã“ã¾ã§æ¥ãŸï¼ã“ã®1æ–‡å­—ã¯æ­£ã—ãé€šã£ãŸ
  totalCorrect += 1;

  // âœ… é€£ç¶šã‚¿ã‚¤ãƒ”ãƒ³ã‚°æ•°ï¼ˆã‚³ãƒ³ãƒœï¼‰ã‚’é€²ã‚ã‚‹
  comboChars += 1;
  updateComboUI();

  // å€™è£œã‚’é•·ã•é †ã«ã—ã¦è¦‹ã›æ–¹ã‚’æ±ºã‚ã‚‹
  candidates.sort((a,b)=>a.length-b.length || a.localeCompare(b));

  const typedLen = p.typed.length;
  const longer = candidates.filter(v => v.length > typedLen);
  const isExact = candidates.some(v => v.length === typedLen);

  // âœ… é€”ä¸­ç¢ºå®šé˜²æ­¢ã€‚ãŸã ã—æœ«å°¾ã« n ã ã‘è¶³ã—ãŸå»¶é•·ã¯ç¢ºå®šOKï¼ˆnn/nnnå¯¾ç­–ï¼‰
  const longerIsOnlyExtraNs = longer.length > 0 && longer.every(v => {
    const rest = v.slice(typedLen);
    return /^n+$/.test(rest);
  });

  // è¡¨ç¤ºï¼šé€”ä¸­ãªã‚‰æ¬¡ã«é•·ã„å€™è£œã‚’å„ªå…ˆã—ã¦è¦‹ã›ã‚‹
  let active = candidates[0];
  if(active.length === typedLen && longer.length){
    const nextLonger = candidates.find(v => v.length > typedLen);
    if(nextLonger) active = nextLonger;
  }

  p.activeTarget = active;
  p.progress = typedLen;
  renderRomaji(p);

  // âœ… ã‚¯ãƒªã‚¢åˆ¤å®šï¼šå®Œå…¨ä¸€è‡´ ANDï¼ˆé•·ã„å€™è£œãªã— or é•·ã„å€™è£œãŒ n è¿½åŠ ã ã‘ï¼‰
  if(isExact && (longer.length === 0 || longerIsOnlyExtraNs)){
    const earned = Math.max(1, Math.round(p.base.length * pointsPerChar));
    score += earned;
    elScore.textContent = String(score);
    clearedCount += 1;
    playAudio(audioAssets.correct);

    // æ™‚é–“åŠ ç®—ï¼ˆã‚«ãƒ¼ãƒ‰å®Œäº†æ™‚ï¼‰
    const add = bonusFromChars(comboChars);
    if(add > 0) timeLeft = clamp(timeLeft + add, 0, 99.9);

    setMsg(`å‡¦ç½®å®Œäº†ï¼ +${earned}pt ï¼ +${add}s`, "ok");
    // æ¬¡ã¸
    despawnPatient();
    spawnPatient();
    if(longerIsOnlyExtraNs) extraNTolerance = 1;
  }
}

  function onKeyDown(e){
    if(!running) return;
    if(e.ctrlKey || e.metaKey || e.altKey) return;

    if(e.key === "Backspace"){
      e.preventDefault();
      resetProgress(0);
      return;
    }
    if(e.key === "Escape"){
      e.preventDefault();
      clearTyped();
      return;
    }
    if(e.key && e.key.length === 1){
      e.preventDefault();
      const k = e.key.toLowerCase();
      if(/[a-z0-9]/.test(k)) handleTypeChar(k);
      return;
    }
  }

  function focusGame(){
    captureInput.focus({preventScroll:true});
  }

  // captureInputã§å…¥åŠ›ã‚’æ‹¾ã†ï¼ˆdocumentã˜ã‚ƒãªãï¼‰
  captureInput.addEventListener("keydown", onKeyDown, {capture:true});
  captureInput.addEventListener("compositionstart", (e) => {
    e.preventDefault();
    captureInput.blur();
    setTimeout(() => focusGame(), 0);
  });
  field.addEventListener("pointerdown", () => focusGame(), {capture:true});
  document.addEventListener("visibilitychange", ()=>{ if(!document.hidden) focusGame(); });

  function startOrRestart(){
    totalTyped = 0;
    totalCorrect = 0;
    totalMiss = 0;
    gameStartAt = now();
    missSlowUntil = 0;

    // åˆæœŸåŒ–
    score=0;
    clearedCount=0;
    comboChars=0;
    timeLeft = START_SECONDS;
    elScore.textContent="0";
    elTime.textContent=timeLeft.toFixed(1);
    updateComboUI();
    setMsg("", "");

    resetPool();
    despawnPatient();

    running=true;
    paused=false;
    lastAt=now();

    finalScore.textContent = "";
    playBtn.textContent = "é–‹å§‹";
    startOverlay.style.display = "none";
    overlaySub.textContent = "ã‚¯ãƒªãƒƒã‚¯ã§é–‹å§‹ï¼ˆå…¥åŠ›ã‚’æœ‰åŠ¹åŒ–ï¼‰";
    modeMenu.style.display = "flex";

    // åŒã˜ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆå†…ã§å¿…ãšãƒ•ã‚©ãƒ¼ã‚«ã‚¹
    focusGame();
    spawnPatient();
    audioAssets.bgm.currentTime = 0;
    audioAssets.bgm.play().catch(() => {});
    requestAnimationFrame(loop);
  }

  playBtn.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();
    focusGame();
    playAudio(audioAssets.click);
    if(paused){
      paused = false;
      running = true;
      lastAt = now();
      startOverlay.style.display = "none";
      setMsg("å†é–‹ï¼", "ok");
      audioAssets.bgm.play().catch(() => {});
      requestAnimationFrame(loop);
      return;
    }
    startOrRestart();
    infoToast.classList.add("show");
    setTimeout(() => infoToast.classList.remove("show"), 1600);
  });

  // åˆæœŸè¡¨ç¤º
  elTime.textContent = START_SECONDS.toFixed(1);
  updateComboUI();
  setMsg("ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã€Œé–‹å§‹ã€ãƒœã‚¿ãƒ³ã§ã‚¹ã‚¿ãƒ¼ãƒˆ", "");
  setMode("easy");
  loadBankFromUrl(DEFAULT_DATA_URL).catch(err => {
    console.error(err);
    BANK = [...BUILTIN_BANK];
    resetPool();
    pointsPerChar = computePointsPerChar(currentMode.basePoints);
  });

  modeButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      if(paused) return;
      playAudio(audioAssets.click);
      setMode(btn.dataset.mode || "easy");
    });
  });

  pauseBtn.addEventListener("click", () => {
    if(!running) return;
    playAudio(audioAssets.click);
    running = false;
    paused = true;
    audioAssets.bgm.pause();
    playBtn.textContent = "å†é–‹";
    overlaySub.textContent = "ä¸€æ™‚åœæ­¢ä¸­";
    startOverlay.style.display = "flex";
    modeMenu.style.display = "none";
    setMsg("ä¸€æ™‚åœæ­¢ä¸­", "");
  });

  restartBtn.addEventListener("click", () => {
    paused = false;
    playAudio(audioAssets.click);
    startOrRestart();
  });

  quitBtn.addEventListener("click", () => {
    if(!running && !paused) return;
    playAudio(audioAssets.click);
    endGame("çµ‚äº†");
  });

  volumeBtn.addEventListener("click", () => {
    volumeIndex = (volumeIndex + 1) % volumeLevels.length;
    applyVolume();
    playAudio(audioAssets.click);
  });

})();
</script>
</body>
</html>
